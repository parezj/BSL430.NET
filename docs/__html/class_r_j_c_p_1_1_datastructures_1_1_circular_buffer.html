<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>BSL430.NET: RJCP.Datastructures.CircularBuffer&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">BSL430.NET
   &#160;<span id="projectnumber">1.2.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_r_j_c_p.html">RJCP</a></li><li class="navelem"><a class="el" href="namespace_r_j_c_p_1_1_datastructures.html">Datastructures</a></li><li class="navelem"><a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html">CircularBuffer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#properties">Properties</a> &#124;
<a href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">RJCP.Datastructures.CircularBuffer&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A simple datastructure to manage an array as a circular buffer.  
 <a href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af18decda3e642fce4e140de2375e67d4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html#af18decda3e642fce4e140de2375e67d4">CircularBuffer</a> (int capacity)</td></tr>
<tr class="memdesc:af18decda3e642fce4e140de2375e67d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate an Array of type T[] of particular capacity.  <a href="#af18decda3e642fce4e140de2375e67d4">More...</a><br /></td></tr>
<tr class="separator:af18decda3e642fce4e140de2375e67d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af815d2e44d5045fa4fdea13bd1591ab5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html#af815d2e44d5045fa4fdea13bd1591ab5">CircularBuffer</a> (T[] array)</td></tr>
<tr class="memdesc:af815d2e44d5045fa4fdea13bd1591ab5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Circular buffer based on an already allocated array.  <a href="#af815d2e44d5045fa4fdea13bd1591ab5">More...</a><br /></td></tr>
<tr class="separator:af815d2e44d5045fa4fdea13bd1591ab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7bb9c18806f30e833956805824fe59a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html#af7bb9c18806f30e833956805824fe59a">CircularBuffer</a> (T[] array, int count)</td></tr>
<tr class="memdesc:af7bb9c18806f30e833956805824fe59a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Circular buffer based on an already allocated array.  <a href="#af7bb9c18806f30e833956805824fe59a">More...</a><br /></td></tr>
<tr class="separator:af7bb9c18806f30e833956805824fe59a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48d3cf3ad804cd6b22e921de5f93dc12"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html#a48d3cf3ad804cd6b22e921de5f93dc12">CircularBuffer</a> (T[] array, int offset, int count)</td></tr>
<tr class="memdesc:a48d3cf3ad804cd6b22e921de5f93dc12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Circular buffer based on an already allocated array.  <a href="#a48d3cf3ad804cd6b22e921de5f93dc12">More...</a><br /></td></tr>
<tr class="separator:a48d3cf3ad804cd6b22e921de5f93dc12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadfb2057db122636b7721fb9262b5bf9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html#aadfb2057db122636b7721fb9262b5bf9">ToArrayIndex</a> (int index)</td></tr>
<tr class="memdesc:aadfb2057db122636b7721fb9262b5bf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an index from the start of the data to read to an array index.  <a href="#aadfb2057db122636b7721fb9262b5bf9">More...</a><br /></td></tr>
<tr class="separator:aadfb2057db122636b7721fb9262b5bf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50e241cdf81c4fb42ac5ff40c9288244"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html#a50e241cdf81c4fb42ac5ff40c9288244">GetReadBlock</a> (int offset)</td></tr>
<tr class="memdesc:a50e241cdf81c4fb42ac5ff40c9288244"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an offset, calculate the length of data that can be read until the end of the block.  <a href="#a50e241cdf81c4fb42ac5ff40c9288244">More...</a><br /></td></tr>
<tr class="separator:a50e241cdf81c4fb42ac5ff40c9288244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80abec3dc79318bb096fd14529cbbb2a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html#a80abec3dc79318bb096fd14529cbbb2a">Consume</a> (int length)</td></tr>
<tr class="memdesc:a80abec3dc79318bb096fd14529cbbb2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consume array elements (freeing space from the beginning) updating pointers in the circular buffer.  <a href="#a80abec3dc79318bb096fd14529cbbb2a">More...</a><br /></td></tr>
<tr class="separator:a80abec3dc79318bb096fd14529cbbb2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaca74dd28d174ddb86e0b8548a676889"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html#aaca74dd28d174ddb86e0b8548a676889">Produce</a> (int length)</td></tr>
<tr class="memdesc:aaca74dd28d174ddb86e0b8548a676889"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produce bytes (allocating space at the end) updating pointers in the circular buffer.  <a href="#aaca74dd28d174ddb86e0b8548a676889">More...</a><br /></td></tr>
<tr class="separator:aaca74dd28d174ddb86e0b8548a676889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4306bff98e415bb3238bcd180618a680"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html#a4306bff98e415bb3238bcd180618a680">Revert</a> (int length)</td></tr>
<tr class="memdesc:a4306bff98e415bb3238bcd180618a680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Revert elements produced to the end of the circular buffer.  <a href="#a4306bff98e415bb3238bcd180618a680">More...</a><br /></td></tr>
<tr class="separator:a4306bff98e415bb3238bcd180618a680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af41b02f6c8de83e723a7116525c7c182"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html#af41b02f6c8de83e723a7116525c7c182">Reset</a> ()</td></tr>
<tr class="memdesc:af41b02f6c8de83e723a7116525c7c182"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the pointers in the circular buffer, effectively noting the circular buffer as empty.  <a href="#af41b02f6c8de83e723a7116525c7c182">More...</a><br /></td></tr>
<tr class="separator:af41b02f6c8de83e723a7116525c7c182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03764d55e9b6fd78b58a3bbf12977edb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html#a03764d55e9b6fd78b58a3bbf12977edb">Append</a> (T[] array)</td></tr>
<tr class="memdesc:a03764d55e9b6fd78b58a3bbf12977edb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy data from array to the end of this circular buffer and update the length.  <a href="#a03764d55e9b6fd78b58a3bbf12977edb">More...</a><br /></td></tr>
<tr class="separator:a03764d55e9b6fd78b58a3bbf12977edb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e5d04b3cfaae9f41011d8c45097ef55"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html#a6e5d04b3cfaae9f41011d8c45097ef55">Append</a> (T[] array, int offset, int count)</td></tr>
<tr class="memdesc:a6e5d04b3cfaae9f41011d8c45097ef55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy data from array to the end of this circular buffer and update the length.  <a href="#a6e5d04b3cfaae9f41011d8c45097ef55">More...</a><br /></td></tr>
<tr class="separator:a6e5d04b3cfaae9f41011d8c45097ef55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9728a92333805eaaaae6945078a4ad4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html#ae9728a92333805eaaaae6945078a4ad4">Append</a> (<a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html">CircularBuffer</a>&lt; T &gt; buffer)</td></tr>
<tr class="memdesc:ae9728a92333805eaaaae6945078a4ad4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy data from the circular buffer to the end of this circular buffer.  <a href="#ae9728a92333805eaaaae6945078a4ad4">More...</a><br /></td></tr>
<tr class="separator:ae9728a92333805eaaaae6945078a4ad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92a93e7c9c188cdf8bce6f5c1d3f691b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html#a92a93e7c9c188cdf8bce6f5c1d3f691b">Append</a> (<a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html">CircularBuffer</a>&lt; T &gt; buffer, int count)</td></tr>
<tr class="memdesc:a92a93e7c9c188cdf8bce6f5c1d3f691b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy data from the circular buffer to the end of this circular buffer.  <a href="#a92a93e7c9c188cdf8bce6f5c1d3f691b">More...</a><br /></td></tr>
<tr class="separator:a92a93e7c9c188cdf8bce6f5c1d3f691b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2b00c844d2d762e349b5cd0be4a6b9d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html#ad2b00c844d2d762e349b5cd0be4a6b9d">Append</a> (<a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html">CircularBuffer</a>&lt; T &gt; buffer, int offset, int count)</td></tr>
<tr class="memdesc:ad2b00c844d2d762e349b5cd0be4a6b9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy data from the circular buffer to the end of this circular buffer.  <a href="#ad2b00c844d2d762e349b5cd0be4a6b9d">More...</a><br /></td></tr>
<tr class="separator:ad2b00c844d2d762e349b5cd0be4a6b9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48e62ce9129f4849ec575ad7975c24c2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html#a48e62ce9129f4849ec575ad7975c24c2">Append</a> (T element)</td></tr>
<tr class="memdesc:a48e62ce9129f4849ec575ad7975c24c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a single element to the end of the Circular Buffer.  <a href="#a48e62ce9129f4849ec575ad7975c24c2">More...</a><br /></td></tr>
<tr class="separator:a48e62ce9129f4849ec575ad7975c24c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23fe5c95e248c9b3d7a45283e1d76e30"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html#a23fe5c95e248c9b3d7a45283e1d76e30">Pop</a> ()</td></tr>
<tr class="memdesc:a23fe5c95e248c9b3d7a45283e1d76e30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a single element from the Circular buffer and consume it.  <a href="#a23fe5c95e248c9b3d7a45283e1d76e30">More...</a><br /></td></tr>
<tr class="separator:a23fe5c95e248c9b3d7a45283e1d76e30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7524ae69bbcbca58bfba02c65ea9cf8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html#ad7524ae69bbcbca58bfba02c65ea9cf8">MoveTo</a> (T[] array)</td></tr>
<tr class="memdesc:ad7524ae69bbcbca58bfba02c65ea9cf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy data from the circular buffer to the array and then consume the data from the circular buffer.  <a href="#ad7524ae69bbcbca58bfba02c65ea9cf8">More...</a><br /></td></tr>
<tr class="separator:ad7524ae69bbcbca58bfba02c65ea9cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c5705e46e1d21a18b6213caad9d00b0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html#a2c5705e46e1d21a18b6213caad9d00b0">MoveTo</a> (T[] array, int offset, int count)</td></tr>
<tr class="memdesc:a2c5705e46e1d21a18b6213caad9d00b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy data from the circular buffer to the array and then consume the data from the circular buffer.  <a href="#a2c5705e46e1d21a18b6213caad9d00b0">More...</a><br /></td></tr>
<tr class="separator:a2c5705e46e1d21a18b6213caad9d00b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71e329c44fe7e70277066977fa930c08"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html#a71e329c44fe7e70277066977fa930c08">CopyTo</a> (T[] array)</td></tr>
<tr class="memdesc:a71e329c44fe7e70277066977fa930c08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy data from the circular buffer to the array.  <a href="#a71e329c44fe7e70277066977fa930c08">More...</a><br /></td></tr>
<tr class="separator:a71e329c44fe7e70277066977fa930c08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acad3a14b8d66b7aa307565fab22cb851"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html#acad3a14b8d66b7aa307565fab22cb851">CopyTo</a> (T[] array, int offset, int count)</td></tr>
<tr class="memdesc:acad3a14b8d66b7aa307565fab22cb851"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy data from the circular buffer to the array.  <a href="#acad3a14b8d66b7aa307565fab22cb851">More...</a><br /></td></tr>
<tr class="separator:acad3a14b8d66b7aa307565fab22cb851"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="properties"></a>
Properties</h2></td></tr>
<tr class="memitem:ae484f7e6b94997f0079b1d826db7debb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html#ae484f7e6b94997f0079b1d826db7debb">Start</a><code> [get]</code></td></tr>
<tr class="memdesc:ae484f7e6b94997f0079b1d826db7debb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get start index into array where data begins.  <a href="#ae484f7e6b94997f0079b1d826db7debb">More...</a><br /></td></tr>
<tr class="separator:ae484f7e6b94997f0079b1d826db7debb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e98be8b2cf3d34965db9d7813443169"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html#a8e98be8b2cf3d34965db9d7813443169">End</a><code> [get]</code></td></tr>
<tr class="memdesc:a8e98be8b2cf3d34965db9d7813443169"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get end index into array where data ends.  <a href="#a8e98be8b2cf3d34965db9d7813443169">More...</a><br /></td></tr>
<tr class="separator:a8e98be8b2cf3d34965db9d7813443169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92b47b98334085d7655fd547b8d46c69"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html#a92b47b98334085d7655fd547b8d46c69">Length</a><code> [get]</code></td></tr>
<tr class="memdesc:a92b47b98334085d7655fd547b8d46c69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get total length of data in array.  <a href="#a92b47b98334085d7655fd547b8d46c69">More...</a><br /></td></tr>
<tr class="separator:a92b47b98334085d7655fd547b8d46c69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ce60906784a0ded9d17cc8cfccf846d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html#a4ce60906784a0ded9d17cc8cfccf846d">Free</a><code> [get]</code></td></tr>
<tr class="memdesc:a4ce60906784a0ded9d17cc8cfccf846d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get total free data in array.  <a href="#a4ce60906784a0ded9d17cc8cfccf846d">More...</a><br /></td></tr>
<tr class="separator:a4ce60906784a0ded9d17cc8cfccf846d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a823e88a213f382917ea0f9f9170c14af"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html#a823e88a213f382917ea0f9f9170c14af">Capacity</a><code> [get]</code></td></tr>
<tr class="memdesc:a823e88a213f382917ea0f9f9170c14af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total capacity of the array.  <a href="#a823e88a213f382917ea0f9f9170c14af">More...</a><br /></td></tr>
<tr class="separator:a823e88a213f382917ea0f9f9170c14af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea438c0f691cf035c02a7fdbce551e01"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html#aea438c0f691cf035c02a7fdbce551e01">WriteLength</a><code> [get]</code></td></tr>
<tr class="memdesc:aea438c0f691cf035c02a7fdbce551e01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get length of continuous available space from the current position to the end of the array or until the buffer is full.  <a href="#aea438c0f691cf035c02a7fdbce551e01">More...</a><br /></td></tr>
<tr class="separator:aea438c0f691cf035c02a7fdbce551e01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d1a90d644b39034c00441161506295a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html#a8d1a90d644b39034c00441161506295a">ReadLength</a><code> [get]</code></td></tr>
<tr class="memdesc:a8d1a90d644b39034c00441161506295a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the length of the continuous amount of data that can be read in a single copy operation from the start of the buffer data.  <a href="#a8d1a90d644b39034c00441161506295a">More...</a><br /></td></tr>
<tr class="separator:a8d1a90d644b39034c00441161506295a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5479e52f4d48c74d313e078c10261c7b"><td class="memItemLeft" align="right" valign="top">T []&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html#a5479e52f4d48c74d313e078c10261c7b">Array</a><code> [get]</code></td></tr>
<tr class="memdesc:a5479e52f4d48c74d313e078c10261c7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the reference to the array that's allocated.  <a href="#a5479e52f4d48c74d313e078c10261c7b">More...</a><br /></td></tr>
<tr class="separator:a5479e52f4d48c74d313e078c10261c7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f027715c774d6a816a266473b8ff44c"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html#a9f027715c774d6a816a266473b8ff44c">this[int index]</a><code> [get, set]</code></td></tr>
<tr class="memdesc:a9f027715c774d6a816a266473b8ff44c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access an element in the array using the Start as index 0.  <a href="#a9f027715c774d6a816a266473b8ff44c">More...</a><br /></td></tr>
<tr class="separator:a9f027715c774d6a816a266473b8ff44c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A simple datastructure to manage an array as a circular buffer. </p>
<p>This class provides simple methods for abstracting a circular buffer. A circular buffer allows for faster access of data by avoiding potential copy operations for data that is at the beginning. </p>
<p>Stream data structures can benefit from this data structure by allocating a single block on the heap of an arbitrary size. If the stream is long-lived the benefits are larger. In the .NET framework (4.0 and earlier), all allocations of data structures that are 80kb and larger are automatically allocated on the heap. The heap is not garbage collected like smaller objects. Instead, new elements are added to the heap in an incremental fashion. It is theoretically possible to exhaust all memory in an application by allocating and deallocating regularly on a heap if such a new heap element requires space and there is not a single block large enough. By using the <a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html#af18decda3e642fce4e140de2375e67d4" title="Allocate an Array of type T[] of particular capacity.">CircularBuffer&lt;T&gt;</a> with the type <code>T</code> as <code>byte</code>, you can preallocate a buffer for a stream of any reasonable size (as a simple example 5MB). That block is allocated once and remains for the lifetime of the stream. No time will be allocated for compacting or garbage collection.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type to use for the array.</td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af18decda3e642fce4e140de2375e67d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af18decda3e642fce4e140de2375e67d4">&#9670;&nbsp;</a></span>CircularBuffer() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html">RJCP.Datastructures.CircularBuffer</a>&lt; T &gt;.<a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html">CircularBuffer</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>capacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate an Array of type T[] of particular capacity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>Size of array to allocate.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af815d2e44d5045fa4fdea13bd1591ab5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af815d2e44d5045fa4fdea13bd1591ab5">&#9670;&nbsp;</a></span>CircularBuffer() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html">RJCP.Datastructures.CircularBuffer</a>&lt; T &gt;.<a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html">CircularBuffer</a> </td>
          <td>(</td>
          <td class="paramtype">T []&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Circular buffer based on an already allocated array. </p>
<p>The array is used as the storage for the circular buffer. No copy of the array is made. The initial index in the circular buffer is index 0 in the array. The array is assumed to be completely used (i.e. it is initialised with zero bytes Free). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Array (zero indexed) to allocate.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af7bb9c18806f30e833956805824fe59a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7bb9c18806f30e833956805824fe59a">&#9670;&nbsp;</a></span>CircularBuffer() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html">RJCP.Datastructures.CircularBuffer</a>&lt; T &gt;.<a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html">CircularBuffer</a> </td>
          <td>(</td>
          <td class="paramtype">T []&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Circular buffer based on an already allocated array. </p>
<p>The array is used as the storage for the circular buffer. No copy of the array is made, only a reference. The initial index in the array is 0. The value <code>count</code> sets the initial length of the array. So an initial <code>count</code> of zero would imply an empty circular buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Array (zero indexed) to allocate.</td></tr>
    <tr><td class="paramname">count</td><td>Length of data in array, beginning from offset 0.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a48d3cf3ad804cd6b22e921de5f93dc12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48d3cf3ad804cd6b22e921de5f93dc12">&#9670;&nbsp;</a></span>CircularBuffer() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html">RJCP.Datastructures.CircularBuffer</a>&lt; T &gt;.<a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html">CircularBuffer</a> </td>
          <td>(</td>
          <td class="paramtype">T []&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Circular buffer based on an already allocated array. </p>
<p>The array is used as the storage for the circular buffer. No copy of the array is made, only a reference. The <code>offset</code> is defined to be the first entry in the circular buffer. This may be any value from zero to the last index (<code>Array.Length - 1</code>). The value <code>count</code> is the amount of data in the array, and it may cause wrapping (so that by setting offset near the end, a value of count may be set so that data can be considered at the end and beginning of the array given). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Array (zero indexed) to allocate.</td></tr>
    <tr><td class="paramname">offset</td><td>Offset of first byte in the array.</td></tr>
    <tr><td class="paramname">count</td><td>Length of data in array, wrapping to the start of the array.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a03764d55e9b6fd78b58a3bbf12977edb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03764d55e9b6fd78b58a3bbf12977edb">&#9670;&nbsp;</a></span>Append() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html">RJCP.Datastructures.CircularBuffer</a>&lt; T &gt;.Append </td>
          <td>(</td>
          <td class="paramtype">T []&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy data from array to the end of this circular buffer and update the length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Array to copy from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes copied.</dd></dl>
<p>Data is copied to the end of the Circular Buffer. The amount of data that could be copied is dependent on the amount of free space. The result is the number of elements from the <code>buffer</code> array that is copied into the Circular Buffer. Pointers in the circular buffer are updated appropriately. </p>

</div>
</div>
<a id="a6e5d04b3cfaae9f41011d8c45097ef55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e5d04b3cfaae9f41011d8c45097ef55">&#9670;&nbsp;</a></span>Append() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html">RJCP.Datastructures.CircularBuffer</a>&lt; T &gt;.Append </td>
          <td>(</td>
          <td class="paramtype">T []&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy data from array to the end of this circular buffer and update the length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Array to copy from.</td></tr>
    <tr><td class="paramname">offset</td><td>Offset to copy data from.</td></tr>
    <tr><td class="paramname">count</td><td>Length of data to copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes copied.</dd></dl>
<p>Data is copied to the end of the Circular Buffer. The amount of data that could be copied is dependent on the amount of free space. The result is the number of elements from the <code>buffer</code> array that is copied into the Circular Buffer. Pointers in the circular buffer are updated appropriately. </p>

</div>
</div>
<a id="ae9728a92333805eaaaae6945078a4ad4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9728a92333805eaaaae6945078a4ad4">&#9670;&nbsp;</a></span>Append() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html">RJCP.Datastructures.CircularBuffer</a>&lt; T &gt;.Append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html">CircularBuffer</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy data from the circular buffer to the end of this circular buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>Buffer to append.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Amount of data appended.</dd></dl>
<p>Data is copied to the end of the Circular Buffer. The amount of data that could be copied is dependent on the amount of free space. The result is the number of elements from the <code>buffer</code> array that is copied into the Circular Buffer. Pointers in the circular buffer are updated appropriately. </p>

</div>
</div>
<a id="a92a93e7c9c188cdf8bce6f5c1d3f691b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92a93e7c9c188cdf8bce6f5c1d3f691b">&#9670;&nbsp;</a></span>Append() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html">RJCP.Datastructures.CircularBuffer</a>&lt; T &gt;.Append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html">CircularBuffer</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy data from the circular buffer to the end of this circular buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>Buffer to append.</td></tr>
    <tr><td class="paramname">count</td><td>Number of bytes to append.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Amount of data appended.</dd></dl>
<p>Data is copied to the end of the Circular Buffer. The amount of data that could be copied is dependent on the amount of free space. The result is the number of elements from the <code>buffer</code> array that is copied into the Circular Buffer. Pointers in the circular buffer are updated appropriately. </p>

</div>
</div>
<a id="ad2b00c844d2d762e349b5cd0be4a6b9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2b00c844d2d762e349b5cd0be4a6b9d">&#9670;&nbsp;</a></span>Append() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html">RJCP.Datastructures.CircularBuffer</a>&lt; T &gt;.Append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html">CircularBuffer</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy data from the circular buffer to the end of this circular buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>Buffer to append.</td></tr>
    <tr><td class="paramname">count</td><td>Number of bytes to append.</td></tr>
    <tr><td class="paramname">offset</td><td>Offset into the buffer to start appending.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Amount of data appended.</dd></dl>
<p>Data is copied to the end of the Circular Buffer. The amount of data that could be copied is dependent on the amount of free space. The result is the number of elements from the <code>buffer</code> array that is copied into the Circular Buffer. Pointers in the circular buffer are updated appropriately. </p>

</div>
</div>
<a id="a48e62ce9129f4849ec575ad7975c24c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48e62ce9129f4849ec575ad7975c24c2">&#9670;&nbsp;</a></span>Append() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html">RJCP.Datastructures.CircularBuffer</a>&lt; T &gt;.Append </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append a single element to the end of the Circular Buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">element</td><td>The element to add at the end of the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Amount of data appended. 1 if successful, 0 if no space available.</dd></dl>

</div>
</div>
<a id="a80abec3dc79318bb096fd14529cbbb2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80abec3dc79318bb096fd14529cbbb2a">&#9670;&nbsp;</a></span>Consume()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html">RJCP.Datastructures.CircularBuffer</a>&lt; T &gt;.Consume </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Consume array elements (freeing space from the beginning) updating pointers in the circular buffer. </p>
<p>This method advances the internal pointers for <em>Start</em> based on the <em>length</em> that should be consumed. The pointer <em>End</em> does not change. It is important that this method does not <em><a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html#af41b02f6c8de83e723a7116525c7c182" title="Reset the pointers in the circular buffer, effectively noting the circular buffer as empty.">Reset()</a></em> the buffer in case that all data is consumed. A common scenario with Streams is to write into the buffer using asynchronous I/O. If a <em><a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html#af41b02f6c8de83e723a7116525c7c182" title="Reset the pointers in the circular buffer, effectively noting the circular buffer as empty.">Reset()</a></em> occurs during an asynchronous I/O <em>ReadFile()</em>, the <em>End</em> pointer is also changed, so that when a <em><a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html#aaca74dd28d174ddb86e0b8548a676889" title="Produce bytes (allocating space at the end) updating pointers in the circular buffer.">Produce()</a></em> occurs on completion of the <em>ReadFile()</em> operation, the pointers are updated, but not using the pointers before the <em><a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html#af41b02f6c8de83e723a7116525c7c182" title="Reset the pointers in the circular buffer, effectively noting the circular buffer as empty.">Reset()</a></em>. No crash would occur (so long as the underlying array is pinned), but data corruption would occur if this method were not used in this particular scenario. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>Amount of data to consume.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a71e329c44fe7e70277066977fa930c08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71e329c44fe7e70277066977fa930c08">&#9670;&nbsp;</a></span>CopyTo() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html">RJCP.Datastructures.CircularBuffer</a>&lt; T &gt;.CopyTo </td>
          <td>(</td>
          <td class="paramtype">T []&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy data from the circular buffer to the array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The array to copy the data to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes that were copied.</dd></dl>
<p>Data is copied from the first element in the array, up to the length of the array. The data from the Circular Buffer is <em>not</em> consumed. You must do this yourself. Else use the <a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html#ad7524ae69bbcbca58bfba02c65ea9cf8" title="Copy data from the circular buffer to the array and then consume the data from the circular buffer.">MoveTo()</a> method. </p>

</div>
</div>
<a id="acad3a14b8d66b7aa307565fab22cb851"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acad3a14b8d66b7aa307565fab22cb851">&#9670;&nbsp;</a></span>CopyTo() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html">RJCP.Datastructures.CircularBuffer</a>&lt; T &gt;.CopyTo </td>
          <td>(</td>
          <td class="paramtype">T []&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy data from the circular buffer to the array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The array to copy the data to.</td></tr>
    <tr><td class="paramname">offset</td><td>Offset into the array to copy to.</td></tr>
    <tr><td class="paramname">count</td><td>Amount of data to copy to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes that were copied.</dd></dl>
<p>Data is copied from the circular buffer into the array specified, at the offset given. The data from the Circular Buffer is <em>not</em> consumed. You must do this yourself. Else use the <a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html#ad7524ae69bbcbca58bfba02c65ea9cf8" title="Copy data from the circular buffer to the array and then consume the data from the circular buffer.">MoveTo()</a> method. </p>

</div>
</div>
<a id="a50e241cdf81c4fb42ac5ff40c9288244"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50e241cdf81c4fb42ac5ff40c9288244">&#9670;&nbsp;</a></span>GetReadBlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html">RJCP.Datastructures.CircularBuffer</a>&lt; T &gt;.GetReadBlock </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an offset, calculate the length of data that can be read until the end of the block. </p>
<p>Similar to the property <code>ReadLength</code>, this function takes an argument <code>offset</code> which is used to determine the length of data that can be read from that offset, until either the end of the block, or the end of the buffer. </p>
<p>This function is useful if you want to read a block of data, not starting from the offset 0 (and you don't want to consume the data before hand to reach an offset of zero).</p>
<p>The example below, will calculate a checksum from the third byte in the block for the length of data. If the block to read from offset 3 can be done in one operation, it will do so. Else it must be done in two operations, first from offset 3 to the end, then from offset 0 for the remaining data.</p>
<p>UInt16 crc; if (buffer.GetReadBlock(3) &gt;= length - 3) { crc = crc16.Compute(buffer.Array, buffer.ToArrayIndex(3), length - 3); } else { crc = crc16.Compute(buffer.Array, buffer.ToArrayIndex(3), buffer.ReadLength - 3); crc = crc16.Compute(crc, buffer.Array, 0, length - buffer.ReadLength); } </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>Offset.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Length.</dd></dl>

</div>
</div>
<a id="ad7524ae69bbcbca58bfba02c65ea9cf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7524ae69bbcbca58bfba02c65ea9cf8">&#9670;&nbsp;</a></span>MoveTo() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html">RJCP.Datastructures.CircularBuffer</a>&lt; T &gt;.MoveTo </td>
          <td>(</td>
          <td class="paramtype">T []&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy data from the circular buffer to the array and then consume the data from the circular buffer. </p>
<p>Data is copied to the first element in the array, up to the length of the array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The array to copy the data to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes that were moved.</dd></dl>

</div>
</div>
<a id="a2c5705e46e1d21a18b6213caad9d00b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c5705e46e1d21a18b6213caad9d00b0">&#9670;&nbsp;</a></span>MoveTo() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html">RJCP.Datastructures.CircularBuffer</a>&lt; T &gt;.MoveTo </td>
          <td>(</td>
          <td class="paramtype">T []&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy data from the circular buffer to the array and then consume the data from the circular buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The array to copy the data to.</td></tr>
    <tr><td class="paramname">offset</td><td>Offset into the array to copy to.</td></tr>
    <tr><td class="paramname">count</td><td>Amount of data to copy to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes that were moved.</dd></dl>
<p>This method is very similar to the CopyTo(T[], int, int) method, but it will also consume the data that was copied also. </p>

</div>
</div>
<a id="a23fe5c95e248c9b3d7a45283e1d76e30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23fe5c95e248c9b3d7a45283e1d76e30">&#9670;&nbsp;</a></span>Pop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html">RJCP.Datastructures.CircularBuffer</a>&lt; T &gt;.Pop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a single element from the Circular buffer and consume it. </p>
<dl class="section return"><dt>Returns</dt><dd>The value at index 0.</dd></dl>

</div>
</div>
<a id="aaca74dd28d174ddb86e0b8548a676889"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaca74dd28d174ddb86e0b8548a676889">&#9670;&nbsp;</a></span>Produce()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html">RJCP.Datastructures.CircularBuffer</a>&lt; T &gt;.Produce </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Produce bytes (allocating space at the end) updating pointers in the circular buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>The number of bytes to indicate that have been added from the index <a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html#a8e98be8b2cf3d34965db9d7813443169" title="Get end index into array where data ends.">End</a> to the end of the array and possibly again from the start of the array if overlapped.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af41b02f6c8de83e723a7116525c7c182"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af41b02f6c8de83e723a7116525c7c182">&#9670;&nbsp;</a></span>Reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html">RJCP.Datastructures.CircularBuffer</a>&lt; T &gt;.Reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the pointers in the circular buffer, effectively noting the circular buffer as empty. </p>

</div>
</div>
<a id="a4306bff98e415bb3238bcd180618a680"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4306bff98e415bb3238bcd180618a680">&#9670;&nbsp;</a></span>Revert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html">RJCP.Datastructures.CircularBuffer</a>&lt; T &gt;.Revert </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Revert elements produced to the end of the circular buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>The number of bytes to remove from the end of the array, moving the <a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html#a8e98be8b2cf3d34965db9d7813443169" title="Get end index into array where data ends.">End</a> property to the left, leaving the <a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html#ae484f7e6b94997f0079b1d826db7debb" title="Get start index into array where data begins.">Start</a> property untouched.</td></tr>
  </table>
  </dd>
</dl>
<p>This method can be used to remove data that has been added to the end of the circular buffer. When using this data structure for streams, you would not use this property to ensure consistency of your stream (the <code>Read</code> operation would consume from your circular buffer and <code>Write</code> would produce data to your circular buffer. </p>

</div>
</div>
<a id="aadfb2057db122636b7721fb9262b5bf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadfb2057db122636b7721fb9262b5bf9">&#9670;&nbsp;</a></span>ToArrayIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html">RJCP.Datastructures.CircularBuffer</a>&lt; T &gt;.ToArrayIndex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an index from the start of the data to read to an array index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index in circular buffer, where an index of 0 is equivalent to the <a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html#ae484f7e6b94997f0079b1d826db7debb" title="Get start index into array where data begins.">Start</a> property.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Index in array that can be used in array based operations.</dd></dl>

</div>
</div>
<h2 class="groupheader">Property Documentation</h2>
<a id="a5479e52f4d48c74d313e078c10261c7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5479e52f4d48c74d313e078c10261c7b">&#9670;&nbsp;</a></span>Array</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T [] <a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html">RJCP.Datastructures.CircularBuffer</a>&lt; T &gt;.Array</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the reference to the array that's allocated. </p>
<p>This property allows you to access the content of the data in the circular buffer in an efficient manner. You can then use this property along with <a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html#ae484f7e6b94997f0079b1d826db7debb" title="Get start index into array where data begins.">Start</a>, <a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html#a8d1a90d644b39034c00441161506295a" title="Get the length of the continuous amount of data that can be read in a single copy operation from the ...">ReadLength</a>, <a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html#a8e98be8b2cf3d34965db9d7813443169" title="Get end index into array where data ends.">End</a> and <a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html#aea438c0f691cf035c02a7fdbce551e01" title="Get length of continuous available space from the current position to the end of the array or until t...">WriteLength</a> for knowing where in the buffer to read and write. </p>

</div>
</div>
<a id="a823e88a213f382917ea0f9f9170c14af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a823e88a213f382917ea0f9f9170c14af">&#9670;&nbsp;</a></span>Capacity</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html">RJCP.Datastructures.CircularBuffer</a>&lt; T &gt;.Capacity</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the total capacity of the array. </p>
<p>Get the total number of elements allocated for the underlying array of the circular buffer. The following rule applies: <a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html#a92b47b98334085d7655fd547b8d46c69" title="Get total length of data in array.">Length</a> + <a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html#a4ce60906784a0ded9d17cc8cfccf846d" title="Get total free data in array.">Free</a> = <a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html#a823e88a213f382917ea0f9f9170c14af" title="Get the total capacity of the array.">Capacity</a>. </p>

</div>
</div>
<a id="a8e98be8b2cf3d34965db9d7813443169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e98be8b2cf3d34965db9d7813443169">&#9670;&nbsp;</a></span>End</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html">RJCP.Datastructures.CircularBuffer</a>&lt; T &gt;.End</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get end index into array where data ends. </p>
<p>This property is useful to know from what element in the underlying array that data can be written to. </p>

</div>
</div>
<a id="a4ce60906784a0ded9d17cc8cfccf846d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ce60906784a0ded9d17cc8cfccf846d">&#9670;&nbsp;</a></span>Free</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html">RJCP.Datastructures.CircularBuffer</a>&lt; T &gt;.Free</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get total free data in array. </p>
<p>Returns the total amount of free elements in the circular buffer. The following rule applies: <a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html#a92b47b98334085d7655fd547b8d46c69" title="Get total length of data in array.">Length</a> + <a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html#a4ce60906784a0ded9d17cc8cfccf846d" title="Get total free data in array.">Free</a> = <a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html#a823e88a213f382917ea0f9f9170c14af" title="Get the total capacity of the array.">Capacity</a>. </p>

</div>
</div>
<a id="a92b47b98334085d7655fd547b8d46c69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92b47b98334085d7655fd547b8d46c69">&#9670;&nbsp;</a></span>Length</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html">RJCP.Datastructures.CircularBuffer</a>&lt; T &gt;.Length</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get total length of data in array. </p>
<p>Returns the amount of allocated data in the circular buffer. The following rule applies: <a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html#a92b47b98334085d7655fd547b8d46c69" title="Get total length of data in array.">Length</a> + <a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html#a4ce60906784a0ded9d17cc8cfccf846d" title="Get total free data in array.">Free</a> = <a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html#a823e88a213f382917ea0f9f9170c14af" title="Get the total capacity of the array.">Capacity</a>. </p>

</div>
</div>
<a id="a8d1a90d644b39034c00441161506295a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d1a90d644b39034c00441161506295a">&#9670;&nbsp;</a></span>ReadLength</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html">RJCP.Datastructures.CircularBuffer</a>&lt; T &gt;.ReadLength</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the length of the continuous amount of data that can be read in a single copy operation from the start of the buffer data. </p>
<p>This function is useful if you need to pass the array to another function that will use the contents of the array. You would pass <a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html#ae484f7e6b94997f0079b1d826db7debb" title="Get start index into array where data begins.">Start</a> as the offset for reading data and <a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html#a8d1a90d644b39034c00441161506295a" title="Get the length of the continuous amount of data that can be read in a single copy operation from the ...">ReadLength</a> as the count. Then based on the amount of data operated on, you would free space with <code><a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html#a80abec3dc79318bb096fd14529cbbb2a" title="Consume array elements (freeing space from the beginning) updating pointers in the circular buffer.">Consume</a>(ReadLength).</code> </p>

</div>
</div>
<a id="ae484f7e6b94997f0079b1d826db7debb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae484f7e6b94997f0079b1d826db7debb">&#9670;&nbsp;</a></span>Start</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html">RJCP.Datastructures.CircularBuffer</a>&lt; T &gt;.Start</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get start index into array where data begins. </p>

</div>
</div>
<a id="a9f027715c774d6a816a266473b8ff44c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f027715c774d6a816a266473b8ff44c">&#9670;&nbsp;</a></span>this[int index]</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html">RJCP.Datastructures.CircularBuffer</a>&lt; T &gt;.this[int index]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span><span class="mlabel">set</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access an element in the array using the Start as index 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index into the array referenced from <em>Start</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Contents of the array.</dd></dl>

</div>
</div>
<a id="aea438c0f691cf035c02a7fdbce551e01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea438c0f691cf035c02a7fdbce551e01">&#9670;&nbsp;</a></span>WriteLength</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html">RJCP.Datastructures.CircularBuffer</a>&lt; T &gt;.WriteLength</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">get</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get length of continuous available space from the current position to the end of the array or until the buffer is full. </p>
<p>This function is useful if you need to pass the array to another function that will then fill the contents of the buffer. You would pass <a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html#a8e98be8b2cf3d34965db9d7813443169" title="Get end index into array where data ends.">End</a> as the offset for where writing the data should start, and <b>WriteLength</b> as the length of buffer space available until the end of the array buffer. After the read operation that writes in to your buffer, the array is completely full, or until the end of the array. </p>
<p>Such a property is necessary in case that the free space wraps around the buffer. Where below <code>X</code> is your stream you wish to read from, <code>b</code> is the circular buffer instantiated as the type <code><a class="el" href="class_r_j_c_p_1_1_datastructures_1_1_circular_buffer.html" title="A simple datastructure to manage an array as a circular buffer.">CircularBuffer</a>{T}</code>. </p><div class="fragment"><div class="line">c = X.Read(b.Array, b.End, b.WriteLength);</div><div class="line">b.Produce(c);</div></div><!-- fragment --><p> If the property <b>WriteLength</b> is not zero, then there is space in the buffer to read data.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>C:/PROJECTS/C#/BSL430.NET/src/BSL430.NET/Library/serialportstream/2.1.4/src/Datastructures/CircularBuffer.cs</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>

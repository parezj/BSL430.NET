\hypertarget{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer}{}\section{R\+J\+C\+P.\+Datastructures.\+Circular\+Buffer$<$ T $>$ Class Template Reference}
\label{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer}\index{RJCP.Datastructures.CircularBuffer$<$ T $>$@{RJCP.Datastructures.CircularBuffer$<$ T $>$}}


A simple datastructure to manage an array as a circular buffer.  


\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_af18decda3e642fce4e140de2375e67d4}{Circular\+Buffer}} (int capacity)
\begin{DoxyCompactList}\small\item\em Allocate an Array of type T\mbox{[}\mbox{]} of particular capacity. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_af815d2e44d5045fa4fdea13bd1591ab5}{Circular\+Buffer}} (T\mbox{[}$\,$\mbox{]} array)
\begin{DoxyCompactList}\small\item\em Circular buffer based on an already allocated array. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_af7bb9c18806f30e833956805824fe59a}{Circular\+Buffer}} (T\mbox{[}$\,$\mbox{]} array, int count)
\begin{DoxyCompactList}\small\item\em Circular buffer based on an already allocated array. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_a48d3cf3ad804cd6b22e921de5f93dc12}{Circular\+Buffer}} (T\mbox{[}$\,$\mbox{]} array, int offset, int count)
\begin{DoxyCompactList}\small\item\em Circular buffer based on an already allocated array. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_aadfb2057db122636b7721fb9262b5bf9}{To\+Array\+Index}} (int index)
\begin{DoxyCompactList}\small\item\em Convert an index from the start of the data to read to an array index. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_a50e241cdf81c4fb42ac5ff40c9288244}{Get\+Read\+Block}} (int offset)
\begin{DoxyCompactList}\small\item\em Given an offset, calculate the length of data that can be read until the end of the block. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_a80abec3dc79318bb096fd14529cbbb2a}{Consume}} (int length)
\begin{DoxyCompactList}\small\item\em Consume array elements (freeing space from the beginning) updating pointers in the circular buffer. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_aaca74dd28d174ddb86e0b8548a676889}{Produce}} (int length)
\begin{DoxyCompactList}\small\item\em Produce bytes (allocating space at the end) updating pointers in the circular buffer. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_a4306bff98e415bb3238bcd180618a680}{Revert}} (int length)
\begin{DoxyCompactList}\small\item\em Revert elements produced to the end of the circular buffer. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_af41b02f6c8de83e723a7116525c7c182}{Reset}} ()
\begin{DoxyCompactList}\small\item\em Reset the pointers in the circular buffer, effectively noting the circular buffer as empty. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_a03764d55e9b6fd78b58a3bbf12977edb}{Append}} (T\mbox{[}$\,$\mbox{]} array)
\begin{DoxyCompactList}\small\item\em Copy data from array to the end of this circular buffer and update the length. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_a6e5d04b3cfaae9f41011d8c45097ef55}{Append}} (T\mbox{[}$\,$\mbox{]} array, int offset, int count)
\begin{DoxyCompactList}\small\item\em Copy data from array to the end of this circular buffer and update the length. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_ae9728a92333805eaaaae6945078a4ad4}{Append}} (\mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer}{Circular\+Buffer}}$<$ T $>$ buffer)
\begin{DoxyCompactList}\small\item\em Copy data from the circular buffer to the end of this circular buffer. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_a92a93e7c9c188cdf8bce6f5c1d3f691b}{Append}} (\mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer}{Circular\+Buffer}}$<$ T $>$ buffer, int count)
\begin{DoxyCompactList}\small\item\em Copy data from the circular buffer to the end of this circular buffer. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_ad2b00c844d2d762e349b5cd0be4a6b9d}{Append}} (\mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer}{Circular\+Buffer}}$<$ T $>$ buffer, int offset, int count)
\begin{DoxyCompactList}\small\item\em Copy data from the circular buffer to the end of this circular buffer. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_a48e62ce9129f4849ec575ad7975c24c2}{Append}} (T element)
\begin{DoxyCompactList}\small\item\em Append a single element to the end of the Circular Buffer. \end{DoxyCompactList}\item 
T \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_a23fe5c95e248c9b3d7a45283e1d76e30}{Pop}} ()
\begin{DoxyCompactList}\small\item\em Retrieve a single element from the Circular buffer and consume it. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_ad7524ae69bbcbca58bfba02c65ea9cf8}{Move\+To}} (T\mbox{[}$\,$\mbox{]} array)
\begin{DoxyCompactList}\small\item\em Copy data from the circular buffer to the array and then consume the data from the circular buffer. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_a2c5705e46e1d21a18b6213caad9d00b0}{Move\+To}} (T\mbox{[}$\,$\mbox{]} array, int offset, int count)
\begin{DoxyCompactList}\small\item\em Copy data from the circular buffer to the array and then consume the data from the circular buffer. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_a71e329c44fe7e70277066977fa930c08}{Copy\+To}} (T\mbox{[}$\,$\mbox{]} array)
\begin{DoxyCompactList}\small\item\em Copy data from the circular buffer to the array. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_acad3a14b8d66b7aa307565fab22cb851}{Copy\+To}} (T\mbox{[}$\,$\mbox{]} array, int offset, int count)
\begin{DoxyCompactList}\small\item\em Copy data from the circular buffer to the array. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Properties}
\begin{DoxyCompactItemize}
\item 
int \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_ae484f7e6b94997f0079b1d826db7debb}{Start}}\hspace{0.3cm}{\ttfamily  \mbox{[}get\mbox{]}}
\begin{DoxyCompactList}\small\item\em Get start index into array where data begins. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_a8e98be8b2cf3d34965db9d7813443169}{End}}\hspace{0.3cm}{\ttfamily  \mbox{[}get\mbox{]}}
\begin{DoxyCompactList}\small\item\em Get end index into array where data ends. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_a92b47b98334085d7655fd547b8d46c69}{Length}}\hspace{0.3cm}{\ttfamily  \mbox{[}get\mbox{]}}
\begin{DoxyCompactList}\small\item\em Get total length of data in array. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_a4ce60906784a0ded9d17cc8cfccf846d}{Free}}\hspace{0.3cm}{\ttfamily  \mbox{[}get\mbox{]}}
\begin{DoxyCompactList}\small\item\em Get total free data in array. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_a823e88a213f382917ea0f9f9170c14af}{Capacity}}\hspace{0.3cm}{\ttfamily  \mbox{[}get\mbox{]}}
\begin{DoxyCompactList}\small\item\em Get the total capacity of the array. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_aea438c0f691cf035c02a7fdbce551e01}{Write\+Length}}\hspace{0.3cm}{\ttfamily  \mbox{[}get\mbox{]}}
\begin{DoxyCompactList}\small\item\em Get length of continuous available space from the current position to the end of the array or until the buffer is full. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_a8d1a90d644b39034c00441161506295a}{Read\+Length}}\hspace{0.3cm}{\ttfamily  \mbox{[}get\mbox{]}}
\begin{DoxyCompactList}\small\item\em Get the length of the continuous amount of data that can be read in a single copy operation from the start of the buffer data. \end{DoxyCompactList}\item 
T \mbox{[}$\,$\mbox{]} \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_a5479e52f4d48c74d313e078c10261c7b}{Array}}\hspace{0.3cm}{\ttfamily  \mbox{[}get\mbox{]}}
\begin{DoxyCompactList}\small\item\em Get the reference to the array that\textquotesingle{}s allocated. \end{DoxyCompactList}\item 
T \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_a9f027715c774d6a816a266473b8ff44c}{this\mbox{[}int index\mbox{]}}}\hspace{0.3cm}{\ttfamily  \mbox{[}get, set\mbox{]}}
\begin{DoxyCompactList}\small\item\em Access an element in the array using the Start as index 0. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
A simple datastructure to manage an array as a circular buffer. 

This class provides simple methods for abstracting a circular buffer. A circular buffer allows for faster access of data by avoiding potential copy operations for data that is at the beginning. 

Stream data structures can benefit from this data structure by allocating a single block on the heap of an arbitrary size. If the stream is long-\/lived the benefits are larger. In the .N\+ET framework (4.\+0 and earlier), all allocations of data structures that are 80kb and larger are automatically allocated on the heap. The heap is not garbage collected like smaller objects. Instead, new elements are added to the heap in an incremental fashion. It is theoretically possible to exhaust all memory in an application by allocating and deallocating regularly on a heap if such a new heap element requires space and there is not a single block large enough. By using the \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_af18decda3e642fce4e140de2375e67d4}{Circular\+Buffer$<$\+T$>$}} with the type {\ttfamily T} as {\ttfamily byte}, you can preallocate a buffer for a stream of any reasonable size (as a simple example 5MB). That block is allocated once and remains for the lifetime of the stream. No time will be allocated for compacting or garbage collection.


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Type to use for the array.\\
\hline
\end{DoxyTemplParams}


\subsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_af18decda3e642fce4e140de2375e67d4}\label{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_af18decda3e642fce4e140de2375e67d4}} 
\index{RJCP.Datastructures.CircularBuffer$<$ T $>$@{RJCP.Datastructures.CircularBuffer$<$ T $>$}!CircularBuffer@{CircularBuffer}}
\index{CircularBuffer@{CircularBuffer}!RJCP.Datastructures.CircularBuffer$<$ T $>$@{RJCP.Datastructures.CircularBuffer$<$ T $>$}}
\subsubsection{\texorpdfstring{CircularBuffer()}{CircularBuffer()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer}{R\+J\+C\+P.\+Datastructures.\+Circular\+Buffer}}$<$ T $>$.\mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer}{Circular\+Buffer}} (\begin{DoxyParamCaption}\item[{int}]{capacity }\end{DoxyParamCaption})}



Allocate an Array of type T\mbox{[}\mbox{]} of particular capacity. 


\begin{DoxyParams}{Parameters}
{\em capacity} & Size of array to allocate.\\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_af815d2e44d5045fa4fdea13bd1591ab5}\label{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_af815d2e44d5045fa4fdea13bd1591ab5}} 
\index{RJCP.Datastructures.CircularBuffer$<$ T $>$@{RJCP.Datastructures.CircularBuffer$<$ T $>$}!CircularBuffer@{CircularBuffer}}
\index{CircularBuffer@{CircularBuffer}!RJCP.Datastructures.CircularBuffer$<$ T $>$@{RJCP.Datastructures.CircularBuffer$<$ T $>$}}
\subsubsection{\texorpdfstring{CircularBuffer()}{CircularBuffer()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer}{R\+J\+C\+P.\+Datastructures.\+Circular\+Buffer}}$<$ T $>$.\mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer}{Circular\+Buffer}} (\begin{DoxyParamCaption}\item[{T \mbox{[}$\,$\mbox{]}}]{array }\end{DoxyParamCaption})}



Circular buffer based on an already allocated array. 

The array is used as the storage for the circular buffer. No copy of the array is made. The initial index in the circular buffer is index 0 in the array. The array is assumed to be completely used (i.\+e. it is initialised with zero bytes Free). 


\begin{DoxyParams}{Parameters}
{\em array} & Array (zero indexed) to allocate.\\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_af7bb9c18806f30e833956805824fe59a}\label{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_af7bb9c18806f30e833956805824fe59a}} 
\index{RJCP.Datastructures.CircularBuffer$<$ T $>$@{RJCP.Datastructures.CircularBuffer$<$ T $>$}!CircularBuffer@{CircularBuffer}}
\index{CircularBuffer@{CircularBuffer}!RJCP.Datastructures.CircularBuffer$<$ T $>$@{RJCP.Datastructures.CircularBuffer$<$ T $>$}}
\subsubsection{\texorpdfstring{CircularBuffer()}{CircularBuffer()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer}{R\+J\+C\+P.\+Datastructures.\+Circular\+Buffer}}$<$ T $>$.\mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer}{Circular\+Buffer}} (\begin{DoxyParamCaption}\item[{T \mbox{[}$\,$\mbox{]}}]{array,  }\item[{int}]{count }\end{DoxyParamCaption})}



Circular buffer based on an already allocated array. 

The array is used as the storage for the circular buffer. No copy of the array is made, only a reference. The initial index in the array is 0. The value {\ttfamily count} sets the initial length of the array. So an initial {\ttfamily count} of zero would imply an empty circular buffer. 


\begin{DoxyParams}{Parameters}
{\em array} & Array (zero indexed) to allocate.\\
\hline
{\em count} & Length of data in array, beginning from offset 0.\\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_a48d3cf3ad804cd6b22e921de5f93dc12}\label{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_a48d3cf3ad804cd6b22e921de5f93dc12}} 
\index{RJCP.Datastructures.CircularBuffer$<$ T $>$@{RJCP.Datastructures.CircularBuffer$<$ T $>$}!CircularBuffer@{CircularBuffer}}
\index{CircularBuffer@{CircularBuffer}!RJCP.Datastructures.CircularBuffer$<$ T $>$@{RJCP.Datastructures.CircularBuffer$<$ T $>$}}
\subsubsection{\texorpdfstring{CircularBuffer()}{CircularBuffer()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer}{R\+J\+C\+P.\+Datastructures.\+Circular\+Buffer}}$<$ T $>$.\mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer}{Circular\+Buffer}} (\begin{DoxyParamCaption}\item[{T \mbox{[}$\,$\mbox{]}}]{array,  }\item[{int}]{offset,  }\item[{int}]{count }\end{DoxyParamCaption})}



Circular buffer based on an already allocated array. 

The array is used as the storage for the circular buffer. No copy of the array is made, only a reference. The {\ttfamily offset} is defined to be the first entry in the circular buffer. This may be any value from zero to the last index ({\ttfamily Array.\+Length -\/ 1}). The value {\ttfamily count} is the amount of data in the array, and it may cause wrapping (so that by setting offset near the end, a value of count may be set so that data can be considered at the end and beginning of the array given). 


\begin{DoxyParams}{Parameters}
{\em array} & Array (zero indexed) to allocate.\\
\hline
{\em offset} & Offset of first byte in the array.\\
\hline
{\em count} & Length of data in array, wrapping to the start of the array.\\
\hline
\end{DoxyParams}


\subsection{Member Function Documentation}
\mbox{\Hypertarget{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_a03764d55e9b6fd78b58a3bbf12977edb}\label{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_a03764d55e9b6fd78b58a3bbf12977edb}} 
\index{RJCP.Datastructures.CircularBuffer$<$ T $>$@{RJCP.Datastructures.CircularBuffer$<$ T $>$}!Append@{Append}}
\index{Append@{Append}!RJCP.Datastructures.CircularBuffer$<$ T $>$@{RJCP.Datastructures.CircularBuffer$<$ T $>$}}
\subsubsection{\texorpdfstring{Append()}{Append()}\hspace{0.1cm}{\footnotesize\ttfamily [1/6]}}
{\footnotesize\ttfamily int \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer}{R\+J\+C\+P.\+Datastructures.\+Circular\+Buffer}}$<$ T $>$.Append (\begin{DoxyParamCaption}\item[{T \mbox{[}$\,$\mbox{]}}]{array }\end{DoxyParamCaption})}



Copy data from array to the end of this circular buffer and update the length. 


\begin{DoxyParams}{Parameters}
{\em array} & Array to copy from.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Number of bytes copied.
\end{DoxyReturn}


Data is copied to the end of the Circular Buffer. The amount of data that could be copied is dependent on the amount of free space. The result is the number of elements from the {\ttfamily buffer} array that is copied into the Circular Buffer. Pointers in the circular buffer are updated appropriately. \mbox{\Hypertarget{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_a6e5d04b3cfaae9f41011d8c45097ef55}\label{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_a6e5d04b3cfaae9f41011d8c45097ef55}} 
\index{RJCP.Datastructures.CircularBuffer$<$ T $>$@{RJCP.Datastructures.CircularBuffer$<$ T $>$}!Append@{Append}}
\index{Append@{Append}!RJCP.Datastructures.CircularBuffer$<$ T $>$@{RJCP.Datastructures.CircularBuffer$<$ T $>$}}
\subsubsection{\texorpdfstring{Append()}{Append()}\hspace{0.1cm}{\footnotesize\ttfamily [2/6]}}
{\footnotesize\ttfamily int \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer}{R\+J\+C\+P.\+Datastructures.\+Circular\+Buffer}}$<$ T $>$.Append (\begin{DoxyParamCaption}\item[{T \mbox{[}$\,$\mbox{]}}]{array,  }\item[{int}]{offset,  }\item[{int}]{count }\end{DoxyParamCaption})}



Copy data from array to the end of this circular buffer and update the length. 


\begin{DoxyParams}{Parameters}
{\em array} & Array to copy from.\\
\hline
{\em offset} & Offset to copy data from.\\
\hline
{\em count} & Length of data to copy.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Number of bytes copied.
\end{DoxyReturn}


Data is copied to the end of the Circular Buffer. The amount of data that could be copied is dependent on the amount of free space. The result is the number of elements from the {\ttfamily buffer} array that is copied into the Circular Buffer. Pointers in the circular buffer are updated appropriately. \mbox{\Hypertarget{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_ae9728a92333805eaaaae6945078a4ad4}\label{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_ae9728a92333805eaaaae6945078a4ad4}} 
\index{RJCP.Datastructures.CircularBuffer$<$ T $>$@{RJCP.Datastructures.CircularBuffer$<$ T $>$}!Append@{Append}}
\index{Append@{Append}!RJCP.Datastructures.CircularBuffer$<$ T $>$@{RJCP.Datastructures.CircularBuffer$<$ T $>$}}
\subsubsection{\texorpdfstring{Append()}{Append()}\hspace{0.1cm}{\footnotesize\ttfamily [3/6]}}
{\footnotesize\ttfamily int \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer}{R\+J\+C\+P.\+Datastructures.\+Circular\+Buffer}}$<$ T $>$.Append (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer}{Circular\+Buffer}}$<$ T $>$}]{buffer }\end{DoxyParamCaption})}



Copy data from the circular buffer to the end of this circular buffer. 


\begin{DoxyParams}{Parameters}
{\em buffer} & Buffer to append.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Amount of data appended.
\end{DoxyReturn}


Data is copied to the end of the Circular Buffer. The amount of data that could be copied is dependent on the amount of free space. The result is the number of elements from the {\ttfamily buffer} array that is copied into the Circular Buffer. Pointers in the circular buffer are updated appropriately. \mbox{\Hypertarget{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_a92a93e7c9c188cdf8bce6f5c1d3f691b}\label{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_a92a93e7c9c188cdf8bce6f5c1d3f691b}} 
\index{RJCP.Datastructures.CircularBuffer$<$ T $>$@{RJCP.Datastructures.CircularBuffer$<$ T $>$}!Append@{Append}}
\index{Append@{Append}!RJCP.Datastructures.CircularBuffer$<$ T $>$@{RJCP.Datastructures.CircularBuffer$<$ T $>$}}
\subsubsection{\texorpdfstring{Append()}{Append()}\hspace{0.1cm}{\footnotesize\ttfamily [4/6]}}
{\footnotesize\ttfamily int \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer}{R\+J\+C\+P.\+Datastructures.\+Circular\+Buffer}}$<$ T $>$.Append (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer}{Circular\+Buffer}}$<$ T $>$}]{buffer,  }\item[{int}]{count }\end{DoxyParamCaption})}



Copy data from the circular buffer to the end of this circular buffer. 


\begin{DoxyParams}{Parameters}
{\em buffer} & Buffer to append.\\
\hline
{\em count} & Number of bytes to append.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Amount of data appended.
\end{DoxyReturn}


Data is copied to the end of the Circular Buffer. The amount of data that could be copied is dependent on the amount of free space. The result is the number of elements from the {\ttfamily buffer} array that is copied into the Circular Buffer. Pointers in the circular buffer are updated appropriately. \mbox{\Hypertarget{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_ad2b00c844d2d762e349b5cd0be4a6b9d}\label{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_ad2b00c844d2d762e349b5cd0be4a6b9d}} 
\index{RJCP.Datastructures.CircularBuffer$<$ T $>$@{RJCP.Datastructures.CircularBuffer$<$ T $>$}!Append@{Append}}
\index{Append@{Append}!RJCP.Datastructures.CircularBuffer$<$ T $>$@{RJCP.Datastructures.CircularBuffer$<$ T $>$}}
\subsubsection{\texorpdfstring{Append()}{Append()}\hspace{0.1cm}{\footnotesize\ttfamily [5/6]}}
{\footnotesize\ttfamily int \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer}{R\+J\+C\+P.\+Datastructures.\+Circular\+Buffer}}$<$ T $>$.Append (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer}{Circular\+Buffer}}$<$ T $>$}]{buffer,  }\item[{int}]{offset,  }\item[{int}]{count }\end{DoxyParamCaption})}



Copy data from the circular buffer to the end of this circular buffer. 


\begin{DoxyParams}{Parameters}
{\em buffer} & Buffer to append.\\
\hline
{\em count} & Number of bytes to append.\\
\hline
{\em offset} & Offset into the buffer to start appending.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Amount of data appended.
\end{DoxyReturn}


Data is copied to the end of the Circular Buffer. The amount of data that could be copied is dependent on the amount of free space. The result is the number of elements from the {\ttfamily buffer} array that is copied into the Circular Buffer. Pointers in the circular buffer are updated appropriately. \mbox{\Hypertarget{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_a48e62ce9129f4849ec575ad7975c24c2}\label{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_a48e62ce9129f4849ec575ad7975c24c2}} 
\index{RJCP.Datastructures.CircularBuffer$<$ T $>$@{RJCP.Datastructures.CircularBuffer$<$ T $>$}!Append@{Append}}
\index{Append@{Append}!RJCP.Datastructures.CircularBuffer$<$ T $>$@{RJCP.Datastructures.CircularBuffer$<$ T $>$}}
\subsubsection{\texorpdfstring{Append()}{Append()}\hspace{0.1cm}{\footnotesize\ttfamily [6/6]}}
{\footnotesize\ttfamily int \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer}{R\+J\+C\+P.\+Datastructures.\+Circular\+Buffer}}$<$ T $>$.Append (\begin{DoxyParamCaption}\item[{T}]{element }\end{DoxyParamCaption})}



Append a single element to the end of the Circular Buffer. 


\begin{DoxyParams}{Parameters}
{\em element} & The element to add at the end of the buffer.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Amount of data appended. 1 if successful, 0 if no space available.
\end{DoxyReturn}
\mbox{\Hypertarget{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_a80abec3dc79318bb096fd14529cbbb2a}\label{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_a80abec3dc79318bb096fd14529cbbb2a}} 
\index{RJCP.Datastructures.CircularBuffer$<$ T $>$@{RJCP.Datastructures.CircularBuffer$<$ T $>$}!Consume@{Consume}}
\index{Consume@{Consume}!RJCP.Datastructures.CircularBuffer$<$ T $>$@{RJCP.Datastructures.CircularBuffer$<$ T $>$}}
\subsubsection{\texorpdfstring{Consume()}{Consume()}}
{\footnotesize\ttfamily void \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer}{R\+J\+C\+P.\+Datastructures.\+Circular\+Buffer}}$<$ T $>$.Consume (\begin{DoxyParamCaption}\item[{int}]{length }\end{DoxyParamCaption})}



Consume array elements (freeing space from the beginning) updating pointers in the circular buffer. 

This method advances the internal pointers for {\itshape Start} based on the {\itshape length} that should be consumed. The pointer {\itshape End} does not change. It is important that this method does not {\itshape \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_af41b02f6c8de83e723a7116525c7c182}{Reset()}}} the buffer in case that all data is consumed. A common scenario with Streams is to write into the buffer using asynchronous I/O. If a {\itshape \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_af41b02f6c8de83e723a7116525c7c182}{Reset()}}} occurs during an asynchronous I/O {\itshape Read\+File()}, the {\itshape End} pointer is also changed, so that when a {\itshape \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_aaca74dd28d174ddb86e0b8548a676889}{Produce()}}} occurs on completion of the {\itshape Read\+File()} operation, the pointers are updated, but not using the pointers before the {\itshape \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_af41b02f6c8de83e723a7116525c7c182}{Reset()}}}. No crash would occur (so long as the underlying array is pinned), but data corruption would occur if this method were not used in this particular scenario. 


\begin{DoxyParams}{Parameters}
{\em length} & Amount of data to consume.\\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_a71e329c44fe7e70277066977fa930c08}\label{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_a71e329c44fe7e70277066977fa930c08}} 
\index{RJCP.Datastructures.CircularBuffer$<$ T $>$@{RJCP.Datastructures.CircularBuffer$<$ T $>$}!CopyTo@{CopyTo}}
\index{CopyTo@{CopyTo}!RJCP.Datastructures.CircularBuffer$<$ T $>$@{RJCP.Datastructures.CircularBuffer$<$ T $>$}}
\subsubsection{\texorpdfstring{CopyTo()}{CopyTo()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily int \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer}{R\+J\+C\+P.\+Datastructures.\+Circular\+Buffer}}$<$ T $>$.Copy\+To (\begin{DoxyParamCaption}\item[{T \mbox{[}$\,$\mbox{]}}]{array }\end{DoxyParamCaption})}



Copy data from the circular buffer to the array. 


\begin{DoxyParams}{Parameters}
{\em array} & The array to copy the data to.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of bytes that were copied.
\end{DoxyReturn}


Data is copied from the first element in the array, up to the length of the array. The data from the Circular Buffer is {\itshape not} consumed. You must do this yourself. Else use the \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_ad7524ae69bbcbca58bfba02c65ea9cf8}{Move\+To()}} method. \mbox{\Hypertarget{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_acad3a14b8d66b7aa307565fab22cb851}\label{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_acad3a14b8d66b7aa307565fab22cb851}} 
\index{RJCP.Datastructures.CircularBuffer$<$ T $>$@{RJCP.Datastructures.CircularBuffer$<$ T $>$}!CopyTo@{CopyTo}}
\index{CopyTo@{CopyTo}!RJCP.Datastructures.CircularBuffer$<$ T $>$@{RJCP.Datastructures.CircularBuffer$<$ T $>$}}
\subsubsection{\texorpdfstring{CopyTo()}{CopyTo()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily int \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer}{R\+J\+C\+P.\+Datastructures.\+Circular\+Buffer}}$<$ T $>$.Copy\+To (\begin{DoxyParamCaption}\item[{T \mbox{[}$\,$\mbox{]}}]{array,  }\item[{int}]{offset,  }\item[{int}]{count }\end{DoxyParamCaption})}



Copy data from the circular buffer to the array. 


\begin{DoxyParams}{Parameters}
{\em array} & The array to copy the data to.\\
\hline
{\em offset} & Offset into the array to copy to.\\
\hline
{\em count} & Amount of data to copy to.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of bytes that were copied.
\end{DoxyReturn}


Data is copied from the circular buffer into the array specified, at the offset given. The data from the Circular Buffer is {\itshape not} consumed. You must do this yourself. Else use the \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_ad7524ae69bbcbca58bfba02c65ea9cf8}{Move\+To()}} method. \mbox{\Hypertarget{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_a50e241cdf81c4fb42ac5ff40c9288244}\label{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_a50e241cdf81c4fb42ac5ff40c9288244}} 
\index{RJCP.Datastructures.CircularBuffer$<$ T $>$@{RJCP.Datastructures.CircularBuffer$<$ T $>$}!GetReadBlock@{GetReadBlock}}
\index{GetReadBlock@{GetReadBlock}!RJCP.Datastructures.CircularBuffer$<$ T $>$@{RJCP.Datastructures.CircularBuffer$<$ T $>$}}
\subsubsection{\texorpdfstring{GetReadBlock()}{GetReadBlock()}}
{\footnotesize\ttfamily int \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer}{R\+J\+C\+P.\+Datastructures.\+Circular\+Buffer}}$<$ T $>$.Get\+Read\+Block (\begin{DoxyParamCaption}\item[{int}]{offset }\end{DoxyParamCaption})}



Given an offset, calculate the length of data that can be read until the end of the block. 

Similar to the property {\ttfamily Read\+Length}, this function takes an argument {\ttfamily offset} which is used to determine the length of data that can be read from that offset, until either the end of the block, or the end of the buffer. 

This function is useful if you want to read a block of data, not starting from the offset 0 (and you don\textquotesingle{}t want to consume the data before hand to reach an offset of zero).

The example below, will calculate a checksum from the third byte in the block for the length of data. If the block to read from offset 3 can be done in one operation, it will do so. Else it must be done in two operations, first from offset 3 to the end, then from offset 0 for the remaining data.

U\+Int16 crc; if (buffer.\+Get\+Read\+Block(3) $>$= length -\/ 3) \{ crc = crc16.\+Compute(buffer.\+Array, buffer.\+To\+Array\+Index(3), length -\/ 3); \} else \{ crc = crc16.\+Compute(buffer.\+Array, buffer.\+To\+Array\+Index(3), buffer.\+Read\+Length -\/ 3); crc = crc16.\+Compute(crc, buffer.\+Array, 0, length -\/ buffer.\+Read\+Length); \} 


\begin{DoxyParams}{Parameters}
{\em offset} & Offset.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Length.
\end{DoxyReturn}
\mbox{\Hypertarget{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_ad7524ae69bbcbca58bfba02c65ea9cf8}\label{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_ad7524ae69bbcbca58bfba02c65ea9cf8}} 
\index{RJCP.Datastructures.CircularBuffer$<$ T $>$@{RJCP.Datastructures.CircularBuffer$<$ T $>$}!MoveTo@{MoveTo}}
\index{MoveTo@{MoveTo}!RJCP.Datastructures.CircularBuffer$<$ T $>$@{RJCP.Datastructures.CircularBuffer$<$ T $>$}}
\subsubsection{\texorpdfstring{MoveTo()}{MoveTo()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily int \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer}{R\+J\+C\+P.\+Datastructures.\+Circular\+Buffer}}$<$ T $>$.Move\+To (\begin{DoxyParamCaption}\item[{T \mbox{[}$\,$\mbox{]}}]{array }\end{DoxyParamCaption})}



Copy data from the circular buffer to the array and then consume the data from the circular buffer. 

Data is copied to the first element in the array, up to the length of the array. 


\begin{DoxyParams}{Parameters}
{\em array} & The array to copy the data to.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of bytes that were moved.
\end{DoxyReturn}
\mbox{\Hypertarget{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_a2c5705e46e1d21a18b6213caad9d00b0}\label{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_a2c5705e46e1d21a18b6213caad9d00b0}} 
\index{RJCP.Datastructures.CircularBuffer$<$ T $>$@{RJCP.Datastructures.CircularBuffer$<$ T $>$}!MoveTo@{MoveTo}}
\index{MoveTo@{MoveTo}!RJCP.Datastructures.CircularBuffer$<$ T $>$@{RJCP.Datastructures.CircularBuffer$<$ T $>$}}
\subsubsection{\texorpdfstring{MoveTo()}{MoveTo()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily int \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer}{R\+J\+C\+P.\+Datastructures.\+Circular\+Buffer}}$<$ T $>$.Move\+To (\begin{DoxyParamCaption}\item[{T \mbox{[}$\,$\mbox{]}}]{array,  }\item[{int}]{offset,  }\item[{int}]{count }\end{DoxyParamCaption})}



Copy data from the circular buffer to the array and then consume the data from the circular buffer. 


\begin{DoxyParams}{Parameters}
{\em array} & The array to copy the data to.\\
\hline
{\em offset} & Offset into the array to copy to.\\
\hline
{\em count} & Amount of data to copy to.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of bytes that were moved.
\end{DoxyReturn}


This method is very similar to the Copy\+To(\+T\mbox{[}$\,$\mbox{]}, int, int) method, but it will also consume the data that was copied also. \mbox{\Hypertarget{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_a23fe5c95e248c9b3d7a45283e1d76e30}\label{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_a23fe5c95e248c9b3d7a45283e1d76e30}} 
\index{RJCP.Datastructures.CircularBuffer$<$ T $>$@{RJCP.Datastructures.CircularBuffer$<$ T $>$}!Pop@{Pop}}
\index{Pop@{Pop}!RJCP.Datastructures.CircularBuffer$<$ T $>$@{RJCP.Datastructures.CircularBuffer$<$ T $>$}}
\subsubsection{\texorpdfstring{Pop()}{Pop()}}
{\footnotesize\ttfamily T \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer}{R\+J\+C\+P.\+Datastructures.\+Circular\+Buffer}}$<$ T $>$.Pop (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Retrieve a single element from the Circular buffer and consume it. 

\begin{DoxyReturn}{Returns}
The value at index 0.
\end{DoxyReturn}
\mbox{\Hypertarget{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_aaca74dd28d174ddb86e0b8548a676889}\label{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_aaca74dd28d174ddb86e0b8548a676889}} 
\index{RJCP.Datastructures.CircularBuffer$<$ T $>$@{RJCP.Datastructures.CircularBuffer$<$ T $>$}!Produce@{Produce}}
\index{Produce@{Produce}!RJCP.Datastructures.CircularBuffer$<$ T $>$@{RJCP.Datastructures.CircularBuffer$<$ T $>$}}
\subsubsection{\texorpdfstring{Produce()}{Produce()}}
{\footnotesize\ttfamily void \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer}{R\+J\+C\+P.\+Datastructures.\+Circular\+Buffer}}$<$ T $>$.Produce (\begin{DoxyParamCaption}\item[{int}]{length }\end{DoxyParamCaption})}



Produce bytes (allocating space at the end) updating pointers in the circular buffer. 


\begin{DoxyParams}{Parameters}
{\em length} & The number of bytes to indicate that have been added from the index \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_a8e98be8b2cf3d34965db9d7813443169}{End}} to the end of the array and possibly again from the start of the array if overlapped.\\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_af41b02f6c8de83e723a7116525c7c182}\label{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_af41b02f6c8de83e723a7116525c7c182}} 
\index{RJCP.Datastructures.CircularBuffer$<$ T $>$@{RJCP.Datastructures.CircularBuffer$<$ T $>$}!Reset@{Reset}}
\index{Reset@{Reset}!RJCP.Datastructures.CircularBuffer$<$ T $>$@{RJCP.Datastructures.CircularBuffer$<$ T $>$}}
\subsubsection{\texorpdfstring{Reset()}{Reset()}}
{\footnotesize\ttfamily void \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer}{R\+J\+C\+P.\+Datastructures.\+Circular\+Buffer}}$<$ T $>$.Reset (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Reset the pointers in the circular buffer, effectively noting the circular buffer as empty. 

\mbox{\Hypertarget{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_a4306bff98e415bb3238bcd180618a680}\label{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_a4306bff98e415bb3238bcd180618a680}} 
\index{RJCP.Datastructures.CircularBuffer$<$ T $>$@{RJCP.Datastructures.CircularBuffer$<$ T $>$}!Revert@{Revert}}
\index{Revert@{Revert}!RJCP.Datastructures.CircularBuffer$<$ T $>$@{RJCP.Datastructures.CircularBuffer$<$ T $>$}}
\subsubsection{\texorpdfstring{Revert()}{Revert()}}
{\footnotesize\ttfamily void \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer}{R\+J\+C\+P.\+Datastructures.\+Circular\+Buffer}}$<$ T $>$.Revert (\begin{DoxyParamCaption}\item[{int}]{length }\end{DoxyParamCaption})}



Revert elements produced to the end of the circular buffer. 


\begin{DoxyParams}{Parameters}
{\em length} & The number of bytes to remove from the end of the array, moving the \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_a8e98be8b2cf3d34965db9d7813443169}{End}} property to the left, leaving the \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_ae484f7e6b94997f0079b1d826db7debb}{Start}} property untouched.\\
\hline
\end{DoxyParams}


This method can be used to remove data that has been added to the end of the circular buffer. When using this data structure for streams, you would not use this property to ensure consistency of your stream (the {\ttfamily Read} operation would consume from your circular buffer and {\ttfamily Write} would produce data to your circular buffer. \mbox{\Hypertarget{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_aadfb2057db122636b7721fb9262b5bf9}\label{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_aadfb2057db122636b7721fb9262b5bf9}} 
\index{RJCP.Datastructures.CircularBuffer$<$ T $>$@{RJCP.Datastructures.CircularBuffer$<$ T $>$}!ToArrayIndex@{ToArrayIndex}}
\index{ToArrayIndex@{ToArrayIndex}!RJCP.Datastructures.CircularBuffer$<$ T $>$@{RJCP.Datastructures.CircularBuffer$<$ T $>$}}
\subsubsection{\texorpdfstring{ToArrayIndex()}{ToArrayIndex()}}
{\footnotesize\ttfamily int \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer}{R\+J\+C\+P.\+Datastructures.\+Circular\+Buffer}}$<$ T $>$.To\+Array\+Index (\begin{DoxyParamCaption}\item[{int}]{index }\end{DoxyParamCaption})}



Convert an index from the start of the data to read to an array index. 


\begin{DoxyParams}{Parameters}
{\em index} & Index in circular buffer, where an index of 0 is equivalent to the \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_ae484f7e6b94997f0079b1d826db7debb}{Start}} property.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Index in array that can be used in array based operations.
\end{DoxyReturn}


\subsection{Property Documentation}
\mbox{\Hypertarget{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_a5479e52f4d48c74d313e078c10261c7b}\label{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_a5479e52f4d48c74d313e078c10261c7b}} 
\index{RJCP.Datastructures.CircularBuffer$<$ T $>$@{RJCP.Datastructures.CircularBuffer$<$ T $>$}!Array@{Array}}
\index{Array@{Array}!RJCP.Datastructures.CircularBuffer$<$ T $>$@{RJCP.Datastructures.CircularBuffer$<$ T $>$}}
\subsubsection{\texorpdfstring{Array}{Array}}
{\footnotesize\ttfamily T \mbox{[}$\,$\mbox{]} \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer}{R\+J\+C\+P.\+Datastructures.\+Circular\+Buffer}}$<$ T $>$.Array\hspace{0.3cm}{\ttfamily [get]}}



Get the reference to the array that\textquotesingle{}s allocated. 

This property allows you to access the content of the data in the circular buffer in an efficient manner. You can then use this property along with \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_ae484f7e6b94997f0079b1d826db7debb}{Start}}, \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_a8d1a90d644b39034c00441161506295a}{Read\+Length}}, \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_a8e98be8b2cf3d34965db9d7813443169}{End}} and \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_aea438c0f691cf035c02a7fdbce551e01}{Write\+Length}} for knowing where in the buffer to read and write. \mbox{\Hypertarget{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_a823e88a213f382917ea0f9f9170c14af}\label{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_a823e88a213f382917ea0f9f9170c14af}} 
\index{RJCP.Datastructures.CircularBuffer$<$ T $>$@{RJCP.Datastructures.CircularBuffer$<$ T $>$}!Capacity@{Capacity}}
\index{Capacity@{Capacity}!RJCP.Datastructures.CircularBuffer$<$ T $>$@{RJCP.Datastructures.CircularBuffer$<$ T $>$}}
\subsubsection{\texorpdfstring{Capacity}{Capacity}}
{\footnotesize\ttfamily int \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer}{R\+J\+C\+P.\+Datastructures.\+Circular\+Buffer}}$<$ T $>$.Capacity\hspace{0.3cm}{\ttfamily [get]}}



Get the total capacity of the array. 

Get the total number of elements allocated for the underlying array of the circular buffer. The following rule applies\+: \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_a92b47b98334085d7655fd547b8d46c69}{Length}} + \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_a4ce60906784a0ded9d17cc8cfccf846d}{Free}} = \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_a823e88a213f382917ea0f9f9170c14af}{Capacity}}. \mbox{\Hypertarget{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_a8e98be8b2cf3d34965db9d7813443169}\label{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_a8e98be8b2cf3d34965db9d7813443169}} 
\index{RJCP.Datastructures.CircularBuffer$<$ T $>$@{RJCP.Datastructures.CircularBuffer$<$ T $>$}!End@{End}}
\index{End@{End}!RJCP.Datastructures.CircularBuffer$<$ T $>$@{RJCP.Datastructures.CircularBuffer$<$ T $>$}}
\subsubsection{\texorpdfstring{End}{End}}
{\footnotesize\ttfamily int \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer}{R\+J\+C\+P.\+Datastructures.\+Circular\+Buffer}}$<$ T $>$.End\hspace{0.3cm}{\ttfamily [get]}}



Get end index into array where data ends. 

This property is useful to know from what element in the underlying array that data can be written to. \mbox{\Hypertarget{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_a4ce60906784a0ded9d17cc8cfccf846d}\label{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_a4ce60906784a0ded9d17cc8cfccf846d}} 
\index{RJCP.Datastructures.CircularBuffer$<$ T $>$@{RJCP.Datastructures.CircularBuffer$<$ T $>$}!Free@{Free}}
\index{Free@{Free}!RJCP.Datastructures.CircularBuffer$<$ T $>$@{RJCP.Datastructures.CircularBuffer$<$ T $>$}}
\subsubsection{\texorpdfstring{Free}{Free}}
{\footnotesize\ttfamily int \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer}{R\+J\+C\+P.\+Datastructures.\+Circular\+Buffer}}$<$ T $>$.Free\hspace{0.3cm}{\ttfamily [get]}}



Get total free data in array. 

Returns the total amount of free elements in the circular buffer. The following rule applies\+: \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_a92b47b98334085d7655fd547b8d46c69}{Length}} + \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_a4ce60906784a0ded9d17cc8cfccf846d}{Free}} = \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_a823e88a213f382917ea0f9f9170c14af}{Capacity}}. \mbox{\Hypertarget{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_a92b47b98334085d7655fd547b8d46c69}\label{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_a92b47b98334085d7655fd547b8d46c69}} 
\index{RJCP.Datastructures.CircularBuffer$<$ T $>$@{RJCP.Datastructures.CircularBuffer$<$ T $>$}!Length@{Length}}
\index{Length@{Length}!RJCP.Datastructures.CircularBuffer$<$ T $>$@{RJCP.Datastructures.CircularBuffer$<$ T $>$}}
\subsubsection{\texorpdfstring{Length}{Length}}
{\footnotesize\ttfamily int \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer}{R\+J\+C\+P.\+Datastructures.\+Circular\+Buffer}}$<$ T $>$.Length\hspace{0.3cm}{\ttfamily [get]}}



Get total length of data in array. 

Returns the amount of allocated data in the circular buffer. The following rule applies\+: \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_a92b47b98334085d7655fd547b8d46c69}{Length}} + \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_a4ce60906784a0ded9d17cc8cfccf846d}{Free}} = \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_a823e88a213f382917ea0f9f9170c14af}{Capacity}}. \mbox{\Hypertarget{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_a8d1a90d644b39034c00441161506295a}\label{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_a8d1a90d644b39034c00441161506295a}} 
\index{RJCP.Datastructures.CircularBuffer$<$ T $>$@{RJCP.Datastructures.CircularBuffer$<$ T $>$}!ReadLength@{ReadLength}}
\index{ReadLength@{ReadLength}!RJCP.Datastructures.CircularBuffer$<$ T $>$@{RJCP.Datastructures.CircularBuffer$<$ T $>$}}
\subsubsection{\texorpdfstring{ReadLength}{ReadLength}}
{\footnotesize\ttfamily int \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer}{R\+J\+C\+P.\+Datastructures.\+Circular\+Buffer}}$<$ T $>$.Read\+Length\hspace{0.3cm}{\ttfamily [get]}}



Get the length of the continuous amount of data that can be read in a single copy operation from the start of the buffer data. 

This function is useful if you need to pass the array to another function that will use the contents of the array. You would pass \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_ae484f7e6b94997f0079b1d826db7debb}{Start}} as the offset for reading data and \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_a8d1a90d644b39034c00441161506295a}{Read\+Length}} as the count. Then based on the amount of data operated on, you would free space with {\ttfamily \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_a80abec3dc79318bb096fd14529cbbb2a}{Consume}}(Read\+Length).} \mbox{\Hypertarget{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_ae484f7e6b94997f0079b1d826db7debb}\label{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_ae484f7e6b94997f0079b1d826db7debb}} 
\index{RJCP.Datastructures.CircularBuffer$<$ T $>$@{RJCP.Datastructures.CircularBuffer$<$ T $>$}!Start@{Start}}
\index{Start@{Start}!RJCP.Datastructures.CircularBuffer$<$ T $>$@{RJCP.Datastructures.CircularBuffer$<$ T $>$}}
\subsubsection{\texorpdfstring{Start}{Start}}
{\footnotesize\ttfamily int \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer}{R\+J\+C\+P.\+Datastructures.\+Circular\+Buffer}}$<$ T $>$.Start\hspace{0.3cm}{\ttfamily [get]}}



Get start index into array where data begins. 

\mbox{\Hypertarget{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_a9f027715c774d6a816a266473b8ff44c}\label{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_a9f027715c774d6a816a266473b8ff44c}} 
\index{RJCP.Datastructures.CircularBuffer$<$ T $>$@{RJCP.Datastructures.CircularBuffer$<$ T $>$}!this\mbox{[}int index\mbox{]}@{this[int index]}}
\index{this\mbox{[}int index\mbox{]}@{this[int index]}!RJCP.Datastructures.CircularBuffer$<$ T $>$@{RJCP.Datastructures.CircularBuffer$<$ T $>$}}
\subsubsection{\texorpdfstring{this[int index]}{this[int index]}}
{\footnotesize\ttfamily T \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer}{R\+J\+C\+P.\+Datastructures.\+Circular\+Buffer}}$<$ T $>$.this\mbox{[}int index\mbox{]}\hspace{0.3cm}{\ttfamily [get]}, {\ttfamily [set]}}



Access an element in the array using the Start as index 0. 


\begin{DoxyParams}{Parameters}
{\em index} & Index into the array referenced from {\itshape Start}.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Contents of the array.
\end{DoxyReturn}
\mbox{\Hypertarget{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_aea438c0f691cf035c02a7fdbce551e01}\label{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_aea438c0f691cf035c02a7fdbce551e01}} 
\index{RJCP.Datastructures.CircularBuffer$<$ T $>$@{RJCP.Datastructures.CircularBuffer$<$ T $>$}!WriteLength@{WriteLength}}
\index{WriteLength@{WriteLength}!RJCP.Datastructures.CircularBuffer$<$ T $>$@{RJCP.Datastructures.CircularBuffer$<$ T $>$}}
\subsubsection{\texorpdfstring{WriteLength}{WriteLength}}
{\footnotesize\ttfamily int \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer}{R\+J\+C\+P.\+Datastructures.\+Circular\+Buffer}}$<$ T $>$.Write\+Length\hspace{0.3cm}{\ttfamily [get]}}



Get length of continuous available space from the current position to the end of the array or until the buffer is full. 

This function is useful if you need to pass the array to another function that will then fill the contents of the buffer. You would pass \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer_a8e98be8b2cf3d34965db9d7813443169}{End}} as the offset for where writing the data should start, and {\bfseries{Write\+Length}} as the length of buffer space available until the end of the array buffer. After the read operation that writes in to your buffer, the array is completely full, or until the end of the array. 

Such a property is necessary in case that the free space wraps around the buffer. Where below {\ttfamily X} is your stream you wish to read from, {\ttfamily b} is the circular buffer instantiated as the type {\ttfamily \mbox{\hyperlink{class_r_j_c_p_1_1_datastructures_1_1_circular_buffer}{Circular\+Buffer}}\{T\}}. 
\begin{DoxyCode}{0}
\DoxyCodeLine{c = X.Read(b.Array, b.End, b.WriteLength);}
\DoxyCodeLine{b.Produce(c);}
\end{DoxyCode}
 If the property {\bfseries{Write\+Length}} is not zero, then there is space in the buffer to read data.

The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
C\+:/\+P\+R\+O\+J\+E\+C\+T\+S/\+C\#/\+B\+S\+L430.\+N\+E\+T/src/\+B\+S\+L430.\+N\+E\+T/\+Library/serialportstream/2.\+1.\+4/src/\+Datastructures/Circular\+Buffer.\+cs\end{DoxyCompactItemize}
